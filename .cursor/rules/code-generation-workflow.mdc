---
description: PRISM AI-assisted code generation workflow with structured development process and context management
globs: ["**/*.js", "**/*.ts", "**/*.jsx", "**/*.tsx", "**/*.py", "**/*.java", "**/*.go", "**/*.php", "**/*.rb", "**/*.cs", "**/.prism/**/*", "**/prism-context.sh", "**/setup-new-project.sh"]
alwaysApply: true
---

# PRISM AI-Assisted Code Generation Workflow

## PRISM Initialization Protocol

### Session Startup (Automatic)
```yaml
initialization_sequence:
  1_time_sync:
    action: WebSearch "current UTC time"
    validate: Compare with system time
    alert: If drift >5 minutes
    log: .prism/.time_sync
  
  2_context_load:
    check: .prism/index.yaml exists
    load: CRITICAL priority items from .prism/context/
    restore: .prism/sessions/current.md
    verify: Dependencies in .prism/context/dependencies.md
  
  3_session_start:
    timestamp: Use synchronized time
    context: Load relevant patterns from .prism/context/patterns.md
    history: Archive previous session if exists
    ready: Signal initialization complete
```

## Development Workflow Standards

### Task Decomposition Strategy

**BREAK DOWN** complex features into manageable components:

- **SINGLE RESPONSIBILITY**: Each component should have one clear responsibility
- **CONTEXT LIMITS**: Limit context to 3-5 entities per generation session
- **SESSION MANAGEMENT**: Restart sessions frequently to prevent context drift
- **CLEAR CONSTRAINTS**: Specify exact libraries, frameworks, and constraints in every prompt

#### Effective Task Breakdown Example

```
❌ Bad: "Build a complete e-commerce system"

✅ Good: Break into focused tasks:
1. User authentication service
2. Product catalog API endpoints
3. Shopping cart management
4. Payment processing integration
5. Order management system
```

### Progressive Enhancement Development Pattern

Follow this structured approach for all AI-assisted development:

#### 1. Basic Functionality Phase
**START** with working basic functionality:
- Focus on core requirements only
- Implement happy path scenarios first
- Ensure basic functionality works end-to-end
- Validate against acceptance criteria

```javascript
// Phase 1: Basic user registration
async function registerUser(email, password) {
  // Basic implementation - happy path only
  const user = await User.create({ email, password });
  return user;
}
```

#### 2. Error Handling Enhancement
**ADD** comprehensive error handling:
- Handle all edge cases and error conditions
- Implement proper validation
- Add meaningful error messages
- Ensure graceful degradation

```javascript
// Phase 2: Add comprehensive error handling
async function registerUser(email, password) {
  try {
    // Validate inputs
    if (!isValidEmail(email)) {
      throw new ValidationError('Invalid email format');
    }
    
    if (!isValidPassword(password)) {
      throw new ValidationError('Password does not meet requirements');
    }
    
    // Check for existing user
    const existingUser = await User.findByEmail(email);
    if (existingUser) {
      throw new ConflictError('Email already registered');
    }
    
    const user = await User.create({ email, password });
    return user;
  } catch (error) {
    logger.error('User registration failed', { email, error: error.message });
    throw error;
  }
}
```

#### 3. Security Implementation
**IMPLEMENT** security measures and input validation:
- Add authentication and authorization
- Implement input sanitization
- Add rate limiting where appropriate
- Ensure secure data handling

```javascript
// Phase 3: Add security measures
async function registerUser(email, password, req) {
  try {
    // Rate limiting check
    await rateLimiter.checkLimit(req.ip, 'user_registration');
    
    // Sanitize inputs
    const sanitizedEmail = sanitizeEmail(email);
    const hashedPassword = await hashPassword(password);
    
    // Validate inputs with security checks
    if (!isValidEmail(sanitizedEmail)) {
      throw new ValidationError('Invalid email format');
    }
    
    if (!isSecurePassword(password)) {
      throw new ValidationError('Password does not meet security requirements');
    }
    
    // Check for existing user
    const existingUser = await User.findByEmail(sanitizedEmail);
    if (existingUser) {
      throw new ConflictError('Email already registered');
    }
    
    const user = await User.create({ 
      email: sanitizedEmail, 
      password: hashedPassword,
      createdAt: new Date(),
      emailVerified: false 
    });
    
    // Trigger email verification
    await sendVerificationEmail(user.email, user.verificationToken);
    
    return { id: user.id, email: user.email, emailVerified: user.emailVerified };
  } catch (error) {
    auditLogger.warn('User registration attempt failed', { 
      email: sanitizedEmail, 
      ip: req.ip, 
      error: error.message 
    });
    throw error;
  }
}
```

#### 4. Performance Optimization
**OPTIMIZE** performance bottlenecks:
- Profile and identify performance issues
- Implement caching where appropriate
- Optimize database queries
- Add monitoring and metrics

#### 5. Comprehensive Testing
**WRITE** comprehensive tests:
- Unit tests for all functions
- Integration tests for workflows
- Performance tests for critical paths
- Security tests for validation

#### 6. Refactoring for Maintainability
**REFACTOR** for clarity and maintainability:
- Extract reusable components
- Improve naming and structure
- Add comprehensive documentation
- Ensure consistent patterns

## Multi-Layer Review Process

### Structured Review Gates

**IMPLEMENT** this review process for all AI-generated code:

#### 1. AI Review (Automated)
- **SYNTAX CHECK**: Verify code syntax and basic structure
- **PATTERN ANALYSIS**: Check against established patterns
- **DEPENDENCY VALIDATION**: Verify all dependencies are available
- **BASIC SECURITY SCAN**: Automated vulnerability scanning

#### 2. Security Check (Manual)
**FOCUS AREAS** for security review:
- Authentication and authorization logic
- Input validation and sanitization
- Data handling and storage
- Encryption and secure communication
- OWASP Top 10 vulnerability assessment

```markdown
## Security Review Checklist
- [ ] Input validation implemented for all user inputs
- [ ] SQL injection prevention measures in place
- [ ] XSS protection implemented
- [ ] Authentication logic reviewed and tested
- [ ] Authorization checks verified
- [ ] Sensitive data handling reviewed
- [ ] Error messages don't leak sensitive information
- [ ] Rate limiting implemented where needed
- [ ] Encryption used for sensitive data
- [ ] Security headers configured properly
```

#### 3. Performance Audit
**ANALYZE** performance characteristics:
- Algorithmic complexity assessment
- Memory usage analysis
- Database query optimization
- Network request optimization
- Benchmark comparison with existing code

#### 4. Architecture Alignment
**VERIFY** consistency with system design:
- Interface compatibility
- Data flow consistency
- Pattern adherence
- Dependency management
- Integration points validation

#### 5. Human Approval
**FINAL REVIEW** by senior developer:
- Overall code quality assessment
- Business logic validation
- User experience considerations
- Long-term maintainability evaluation

## PRISM Context Management Best Practices

### Managing AI Context with PRISM

#### Session Management
- **PRISM INITIALIZATION**: Every session starts with time sync and context load
- **CONTEXT PERSISTENCE**: Use `.prism/sessions/current.md` for session continuity
- **FRESH STARTS**: Use `./prism-context.sh archive` before switching major tasks
- **FOCUSED SESSIONS**: Limit each session to single feature/component (3-5 entities max)

#### PRISM Context Corruption Prevention
- **ARCHIVE FREQUENTLY**: Use `./prism-context.sh archive` every 5-10 operations
- **INCREMENTAL UPDATES**: Update `.prism/context/` files incrementally
- **VALIDATION LOGGING**: Log validation results in `.prism/sessions/current.md`
- **PERSISTENT DOCUMENTATION**: All decisions logged in `.prism/context/decisions.md`

### PRISM Shell Commands Integration

#### Essential Commands During Development
```bash
# Check PRISM system status
./prism-context.sh status

# Add important decisions
./prism-context.sh add decisions.md CRITICAL "auth,security" "Chose JWT for stateless auth"

# Query existing context
./prism-context.sh query "authentication"

# Archive current session
./prism-context.sh archive

# Export context for team sharing
./prism-context.sh export
```

#### Effective Prompt Engineering

**SET CONTEXT** clearly in every prompt:

```
You are a senior software engineer working on a Node.js e-commerce API.
Architecture: RESTful API with Express.js, PostgreSQL database, Redis cache
Patterns: Repository pattern, dependency injection, async/await
Style: ES6+, functional programming preferred, comprehensive error handling
Testing: Jest framework, minimum 85% coverage required
```

**SPECIFY TASK** with clear inputs, outputs, and constraints:

```
Task: Create user authentication middleware
Input: HTTP request with Authorization header
Output: Middleware function that validates JWT and adds user to req.user
Constraints: 
- Must handle token expiry gracefully
- Rate limiting for failed attempts
- Comprehensive logging for security events
- Compatible with existing auth service
```

**REQUEST REASONING** for complex problems:

```
Please implement the solution using chain-of-thought reasoning:
1. Analyze the requirements
2. Consider security implications  
3. Design the solution architecture
4. Implement with error handling
5. Add comprehensive testing
6. Document assumptions and limitations
```

## Workflow Implementation Guidelines

### PRISM Integrated Workflow: qnew-qplan-qcode-qcheck-qgit

#### qnew: New Task Initialization
- **TIME SYNC**: WebSearch "current UTC time" and log to `.prism/.time_sync`
- **LOAD CONTEXT**: Execute `./prism-context.sh status` to verify system
- **CHECK SESSION**: Review `.prism/sessions/current.md` for continuity
- **DEFINE TASK**: Update `.prism/sessions/current.md` with new task details

#### qplan: Planning Phase
- **ARCHITECTURE REVIEW**: Load `.prism/context/architecture.md` for system understanding
- **PATTERN CHECK**: Reference `.prism/context/patterns.md` for established patterns
- **DECISION QUERY**: Use `./prism-context.sh query "[technology]"` to find related decisions
- **PLAN DOCUMENTATION**: Update `.prism/sessions/current.md` with implementation plan

#### qcode: Implementation Phase
- **PROGRESSIVE ENHANCEMENT**: Follow 6-phase pattern (Basic → Secure → Optimize → Test → Refactor)
- **CONTEXT TRACKING**: Log important decisions with `./prism-context.sh add decisions.md HIGH "tag1,tag2" "[decision]"`
- **PATTERN UPDATES**: Update `.prism/context/patterns.md` when new patterns emerge
- **SESSION LOGGING**: Continuously update `.prism/sessions/current.md`

#### qcheck: Quality Validation
- **SECURITY SCAN**: Log findings in `.prism/references/security-rules.md`
- **PERFORMANCE VALIDATION**: Document benchmarks in `.prism/sessions/current.md`
- **ARCHITECTURE ALIGNMENT**: Verify against `.prism/context/architecture.md`
- **DEPENDENCY CHECK**: Validate against `.prism/context/dependencies.md`

#### qgit: Version Control & Session Archive
- **COMMIT WITH ATTRIBUTION**: Include PRISM context references in commit messages
- **SESSION ARCHIVE**: Execute `./prism-context.sh archive` to save session history
- **CONTEXT UPDATE**: Update `.prism/context/` files with new knowledge
- **TIME STAMP**: All logs use synchronized PRISM time

### Continuous Quality Monitoring

#### Development Metrics to Track
- **AI EFFECTIVENESS**: Success rate >80%, intervention rate <20%
- **CODE QUALITY**: Maintainability index >60, complexity <10
- **DEVELOPMENT VELOCITY**: 25% improvement in time-to-market
- **DEFECT RATE**: <5% escape rate for AI-generated code

#### Quality Gate Enforcement
```markdown
## Before Code Merge Checklist
- [ ] Progressive enhancement pattern followed
- [ ] Multi-layer review completed
- [ ] Security validation passed
- [ ] Performance benchmarks met
- [ ] Test coverage ≥85%
- [ ] Documentation updated
- [ ] Architecture alignment verified
- [ ] Human approval obtained
```

## Emergency Response Protocols

### Context Drift Detection
**SIGNS** of context corruption:
- Inconsistent coding patterns
- Violation of established conventions
- Decreased code quality
- Repetitive or nonsensical suggestions

**RESPONSE**:
1. Immediately save current work
2. Clear context and restart session
3. Review last 3-5 generations for issues
4. Document problematic context patterns

### Quality Degradation Response
**WHEN** output quality drops significantly:
1. Stop generation immediately
2. Review recent context for drift patterns
3. Reset with fresh context and specific constraints
4. Implement additional validation steps
5. Document lessons learned